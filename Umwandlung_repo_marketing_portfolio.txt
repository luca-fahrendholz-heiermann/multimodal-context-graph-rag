Du bist Codex.
Du arbeitest in einem bestehenden Git-Repository.
Ziel: Das Repository so aufräumen und professionalisieren, dass es als öffentliches Portfolio-Projekt in Bewerbungen referenzierbar ist.
Wichtig: Funktionalität darf nicht kaputtgehen.
Arbeite in kleinen, sauberen Commits mit klaren Commit-Messages.
Wenn du unsicher bist, mache Änderungen konservativ.

Leitplanken (nicht verhandelbar)
- Keine Secrets, Tokens, Keys, Passwörter oder sensible URLs in Code oder Doku.
- Keine PII in Beispieldaten, Logs oder Screenshots.
- Keine internen Prompt-Dateien im Stil "Du bist Codex, mach X" im öffentlichen Repo.
  - Wenn solche Dateien für Entwicklung nützlich sind: umbenennen und professionalisieren (z.B. DEVELOPMENT.md) und Inhalte bereinigen.
- Keine Breaking Changes ohne Migration oder klare Dokumentation.
- Bestehende Funktionalität muss nach Änderungen weiterhin laufen (mindestens: build, lint, start, basic flow).
- Keine unnötigen Großrefactors.

Phase 0: Analyse (nur lesen)
1) Erstelle eine kurze Repo-Analyse:
   - Tech-Stack (Frontend/Backend, Sprachen, Frameworks)
   - Entry Points / Startkommandos
   - Hauptmodule und deren Verantwortung
   - Datenfluss (Ingestion -> Processing -> Indexing -> Query -> UI)
   - Externe Abhängigkeiten (DB, Vectorstore, LLM Provider)
2) Identifiziere Risiken für Public Release:
   - mögliche Secrets/PII
   - Demo-Daten
   - Logging/Tracing
   - Konfigurationsdateien
3) Schreibe eine TODO-Liste, welche Maßnahmen du in welcher Reihenfolge umsetzen wirst.

Phase 1: Security & Hygiene
4) Suche nach Secrets/PII:
   - grep nach "sk-", "apikey", "token", "secret", "password", "Authorization", ".env", "supabase", "smtp", "mail", "openai"
   - prüfe Config Files, sample data, logs, dumps
5) Entferne/ersetze problematische Inhalte:
   - .env entfernen, .env.example erstellen
   - demo keys durch Platzhalter ersetzen
   - logging so anpassen, dass keine Inhalte/PII geloggt werden
6) Ergänze:
   - .gitignore (logs, tmp, data, node_modules, dist, build, env files)
   - SECURITY.md (kurz, klar)
   - CONTRIBUTING.md (minimal)

Phase 2: Repo-Struktur und Naming
7) Vereinheitliche Struktur:
   - frontend/ backend/ (oder apps/web, apps/api), docs/, scripts/
   - keine "misc" oder "old" Ordner im Root. Falls nötig: archive/ mit Hinweis.
8) Räum auf:
   - ungenutzte Dateien entfernen
   - doppelte Konfiguration zusammenführen
   - konsistente Package Scripts (dev, build, lint, test, start)

Phase 3: Dokumentation, Demo, Portfolio-Readiness
9) Erstelle/überarbeite README.md:
   - One-liner: Was ist das Projekt?
   - Features (5-7 bullets)
   - Architekturübersicht
   - Schnellstart (Demo Mode)
   - Konfiguration (.env.example Erklärung)
   - Datenschutz/Security Prinzipien (no PII logs, redaction)
   - Limitations (ehrlich, kurz)
   - Roadmap (mit Platzhaltern, die der Autor später ergänzt)
   - Screenshots (Platzhalter-Sektion mit Dateinamen, die später ersetzt werden)
10) Erstelle DEMO_MODE:
   - Implementiere einen "stub provider" für Embeddings/LLM, sodass das Projekt ohne echte API Keys startet.
   - Füge sample documents ohne PII hinzu (synthetisch).
   - Stelle sicher: "npm run dev" oder "docker compose up" funktioniert in Demo Mode.

Phase 4: Architekturdiagramm automatisch erzeugen
11) Verstehe die Architektur aus dem Code:
   - identifiziere Komponenten und Schnittstellen
   - erstelle ein Diagramm als Mermaid in docs/architecture.md und im README einbetten.
   - Diagramm soll enthalten: UI, API, Ingestion, Processing, Vectorstore/DB, Graph Layer, LLM Provider (real/stub).
12) Ergänze eine "Architecture Decision Records" Sektion (optional):
   - docs/adr/0001-...md für zentrale Entscheidungen (vector store, logging, tenancy, etc.)
   - kurz halten.

Phase 5: Qualitätssignale
13) Füge minimale Checks hinzu:
   - lint config (falls nicht vorhanden)
   - minimale tests (mindestens: pii_filter / redaction oder core utils)
   - GitHub Actions CI (optional, wenn schnell möglich): lint + test + build
14) Stelle sicher, dass alles grün ist:
   - Build läuft
   - Demo Mode läuft
   - Keine Secrets im Repo

Output-Anforderungen
- Arbeite in Commits. Nach jedem Commit: kurze Zusammenfassung (was, warum, wie getestet).
- Erstelle am Ende eine Übersicht:
  - Welche Dateien neu/angepasst wurden
  - Wie man lokal startet (Demo Mode)
  - Wo das Architekturdiagramm ist
  - Welche Roadmap- und Screenshot-Platzhalter existieren

Roadmap- und Screenshot-Platzhalter
- README: Abschnitt "Roadmap" mit 5 Platzhaltern im Format:
  - [ ] <Roadmap Item Placeholder>
- README: Abschnitt "Screenshots" mit Platzhaltern:
  - docs/screenshots/01_ingestion.png
  - docs/screenshots/02_chat.png
  - docs/screenshots/03_evidence_viewer.png
  - docs/screenshots/04_graph_builder.png
  - docs/screenshots/05_settings.png
  (Lege leere Platzhalterdateien an oder Hinweise, aber keine Fake-Bilder.)

Los. Beginne mit Phase 0 und arbeite dich Schritt für Schritt durch.